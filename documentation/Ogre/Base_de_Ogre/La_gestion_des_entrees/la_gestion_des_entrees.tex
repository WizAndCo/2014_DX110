\chapter{La gestion des entr\'ees}




\section{Les frame listeners}





\subsection{Des ''\'ecouteurs d'images'' ?}
\subsubsection{Utilit\'e}
Lorsque vous g\'erez les entr\'ees de l'utilisateur (et m\^eme pour faire des calculs divers durant l'ex\' ecution de votre programme), l'ordinateur effectue les instructions n\'ecessaires entre deux images (ou frames en anglais), donc pendant un temps tr\`es court.

En pratique, le moteur fonctionne dans une boucle, qui ne fait qu'afficher une image, puis fait des calculs; et ainsi de suite, sans s'arr\^eter. Il est donc possible pour le programmeur de donner ses instructions avant qu'une image soit rendue, ou bien apr\`es, ou bien m\^eme pendant que la carte graphique fait le rendu graphique.

Lorsque l'on aura vu comment cr\'eer cette boucle de rendu, nous serons \`{a} m\^eme de donner les instructions de la mani\`ere dont nous le d\'esirons. En attendant, je vais vous pr\'esenter une classe qui a l'avantage de permettre de faire tout ce que je viens de vous expliquer de fa\c{c}on tr\`es simple: le frame listener.



\subsubsection{Les m\'ethodes \`{a} conna\^itre}
Un frame listener est une classe interface qui poss\`ede trois m\'ethodes, dont voici les prototypes:

\begin{itemize}
\item virtual bool frameStarted(const FrameEvent\& evt): est appel\'ee avant que la frame ne soit rendue (frameStarted)
\item virtual bool frameRenderingQueued(const FrameEvent\& evt): est appel\'ee apr\`es que la frame ait \'et\'e rendue (frameEnded)
\item virtual bool frameEnded(const FrameEvent\& evt): est appel\'ee apr\`es que le processeur graphique ait re\c{c}u les instructions pour le rendu (frameRenderingQueued)\newline
\end{itemize}
    


En cr\'eant un objet d\'eriv\'e de la classe frame listener dans votre application et en r\'eimpl\'ementant ces m\'ethodes virtuelles, vous avez donc la possibilit\'e de demander \`{a} Ogre d'effectuer les calculs dont vous avez besoin \`{a} chaque image.



frameStarted() et frameEnded() sont tr\`es similaires, \'etant donn\'e qu'elles ont pour seule diff\'erence d'\^etre appel\'ees respectivement au d\'ebut et \`{a} la fin de la boucle de rendu. Mais comme on est dans une boucle, en r\'ealit\'e il ne se passe quasiment rien entre l'appel \`{a} frameEnded() et celui \`{a} frameStarted(). La diff\'erence peut \^etre utile par exemple si vous avez un calcul qui semble plus logique d'effectuer apr\`es que l'image soit rendue plut\^ot qu'avant, mais ce n'est qu'une question de lecture du code selon moi.


En revanche la derni\`ere (frameRenderingQueued) est plus subtile. Comme je l'ai dit, elle est appel\'ee d\`es que la carte graphique re\c{c}oit les instructions n\'ecessaires pour afficher l'image \`{a} rendre.


Vous le savez probablement, c'est une op\'eration tr\`es co\^uteuse en ressources et c'est souvent ce qui ralentit les jeux vid\'eo mettant en jeu de nombreux effets graphiques. Pendant ce temps-l\`{a}, le processeur central attend que \c{c}a se passe. Par cons\'equent, si vous appelez la m\'ethode frameRenderingQueued() pour faire des calculs, vous \'evitez d'avoir un processeur peu occup\'e pendant que la carte graphique fait son boulot !

De mani\`ere g\'en\'erale, on pourra utiliser cette m\'ethode pour des op\'erations lourdes dont on sait qu'elles seront r\'ep\'et\'ees \`{a} chaque image, afin de rentabiliser l'utilisation du processeur.




\subsubsection{Contr\^ole de l'ex\'ecution}

La valeur de retour des m\'ethodes d'un frame listener est un bool\'een r\'ecup\'er\'e par Ogre pour savoir s'il doit continuer (true) ou non (false) l'ex\'ecution du programme.



\subsubsection{Utiliser plusieurs frame listeners}

Il est possible de cr\'eer autant de frame listeners que vous le d\'esirez, pour effectuer des op\'erations diverses. En revanche, il est conseill\'e de ne pas en abuser pour \'eviter de trop segmenter votre application, il peut \^etre int\'eressant d'appeler d'autres fonctions \`{a} partir d'un frame listener plut\^ot que d'en cr\'eer trop.

Enfin, et c'est l\`{a} le plus important:
\textbf{L'ordre d'ex\'ecution des frame listeners est laiss\'e aux soins du moteur. Vous n'avez AUCUN contr\^ole dessus !}

En d'autres termes, si vous avez besoin d'effectuer des op\'erations dans un ordre pr\'ecis, ne les mettez pas dans des frame listeners diff\'erents, car vous ne pourrez pas d\'ecider de l'ordre d'ex\'ecution. Il faut alors laisser un seul frame listener g\'erer les op\'erations, ou ne pas passer par eux (ce sera possible lorsque nous attaquerons la boucle de rendu).



\subsection{Le frame listener en pratique}

Comme nous allons vouloir red\'efinir les m\'ethodes du frame listener, il faut en faire une classe d\'eriv\'ee. Vu que nous sommes dans la gestion des entr\'ees, nous allons tout de suite pr\'eparer le terrain en cr\'eant une classe InputListener d\'erivant de ExampleFrameListener.

Je d\'erive ici de la classe ExampleFrameListener, elle-m\^eme d\'eriv\'ee de FrameListener, car la classe ExampleApplication met d\'ej\`{a} en place une gestion des entr\'ees et attend un ExampleFrameListener. Cette classe s'occupe aussi de construire les objets n\'ecessaires \`{a} l'\'ecoute des entr\'ees souris/clavier, ce que nous aborderons ult\'erieurement.
Cependant, la m\'ethode de traitement reste identique, nous allons juste devoir red\'efinir frameRenderingQueued() pour impl\'ementer notre propre gestion des entr\'ees \`{a} la place de celle pr\'evue par ExampleFrameListener.


\begin{lstlisting}[caption={InputListener.h}]
#include ''ExampleFrameListener.h''
class InputListener: public ExampleFrameListener
{
public:
    InputListener(RenderWindow* win, Camera* cam, sceneManager *sceneMgr, bool bufferedKeys = false, bool bufferedMouse = false, bool bufferedJoy = false );
    virtual bool frameRenderingQueued(const FrameEvent& evt);

private:
    Ogre::sceneManager *msceneMgr; //pointeur sur le scene Manager, qui servira a retrouver des objets dans la scene.
    bool mToucheAppuyee;	 //pour garder une trace de l etat dans lequel se trouve une touche particuliere.

    /*distance de deplacement de la camera et sa vitesse, puis des angles de rotation.*/
    Ogre::Real mMouvement;
    Ogre::Real mVitesse;
    Ogre::Real mVitesseRotation;

	/*angles de rotation.*/
    Ogre::Radian mRotationX;
    Ogre::Radian mRotationY;
};
\end{lstlisting}



Dans votre fichier InputListener.cpp, pr\'eparez le constructeur ainsi que l'impl\'ementation des m\'ethodes, avec un corps vide pour l'instant:

%je ne sais pas si [language=cpp] passe et s il est utile
\begin{lstlisting}[caption={InputListener.cpp}]
/*
Arguments:
RenderWindow* win: votre RenderWindow pour l'application
Camera* cam: la camera que vous utilisez
sceneManager *sceneMgr: le scene Manager
bool bufferedKeys: indique si vous desirez utiliser le buffer pour le clavier
bool bufferedMouse: indique si vous desirez utiliser le buffer pour la souris
bool bufferedJoy: indique si vous desirez utiliser le buffer pour le joystick
*/
InputListener::InputListener(RenderWindow* win, Camera* cam, sceneManager *sceneMgr, bool bufferedKeys, bool bufferedMouse, bool bufferedJoy) 
      : ExampleFrameListener(win, cam, bufferedKeys, bufferedMouse, bufferedJoy)
{
    msceneMgr = sceneMgr;
    mVitesse = 100;
    mVitesseRotation = 0.3;
    mToucheAppuyee = false;
}
\end{lstlisting}



Il n'y a pas de constructeur \'ecrit pour les frame listeners, car c'est une classe interface\footnote{que je sache il n'y a pas d'interface en C++}\footnote{pas de constructeur parce que c'est une classe interface ??}, seules les trois m\'ethodes que j'ai pr\'esent\'ees plus haut importent. En revanche, la classe ExampleFrameListener poss\`ede un constructeur qui pr\'epare le terrain pour l'utilisation des entr\'ees, que j'appelle dans ma classe d\'eriv\'ee. 

Les trois bool\'eens en param\`etres indiquent si vous d\'esirez utiliser le buffer respectivement pour le clavier, la souris et le joystick. Comme ce sera l'objet de la derni\`ere partie de ce chapitre, je mets par d\'efaut false (dans le .h).

Dans le corps du constructeur, j'initialise mes attributs mSceneMgr, mVitesse et mToucheAppuyee, qui nous serviront par la suite.

Il n'y a pas d'attribut \`{a} ajouter dans notre classe PremiereApplication, la classe ExampleApplication contient d\'ej\`{a} un pointeur sur un ExampleFrameListener.

       




































\section{OIS}


Pour g\'erer les entr\'ees de l'utilisateur, nous allons utiliser la biblioth\`eque OIS \footnote{Object Oriented Input System, c'est \`a dire: Syst\`eme d'entr\'ees orient\'e objet}, qui est distribu\'ee par d\'efaut avec le SDK d'Ogre. Comme je l'ai dit en introduction de ce cours, un moteur 3D n'a pas de m\'ethodes pour g\'erer autre chose que ce qui s'affiche sur votre \'ecran. C'est pourquoi nous utiliserons cette biblioth\`eque pour r\'ecup\'erer les actions du joueur.\newline


Pour ce faire, OIS repr\'esente les p\'eriph\'eriques d'entr\'ee par des objets, qui sont les suivants:

\begin{itemize}
\item Mouse pour la souris;
\item Keyboard pour le clavier;
\item Joystick pour les joysticks ou manettes de jeu.\newline
\end{itemize}
    



Qui dit nouvelle biblioth\`eque dit nouveau namespace ! Ces classes se trouvent donc dans l'espace de nom OIS.\newline

Les touches du clavier et les boutons de la souris sont des \'enum\'erations, d\'efinies comme ceci:

\begin{itemize}
\item OIS::KC\_NOMDELATOUCHE pour le clavier;
\item OIS::MB\_NOMDUBOUTON pour la souris.
\end{itemize}


Ce qui donne par exemple OIS::KC\_A pour la touche 'A'\footnote{la touche 'Entr\'ee' s'appelle 'Return' en anglais, ne cherchez donc pas OIS::KC\_ENTER, vous ne trouverez pas.}, ou OIS::MC\_Left pour le clic gauche.\newline

Une derni\`ere chose bonne \`{a} savoir: les codes de touches d'OIS correspondent aux touches physiques d'un clavier QWERTY. Ce qui signifie par exemple que OIS::KC\_A correspond \`{a} la touche Q sur votre clavier AZERTY.\newline

Afin d'utiliser OIS, il faut inclure le header correspondant. Celui-ci se trouve dans le dossier OIS du dossier include, on ajoutera donc la ligne de pr\'eprocesseur suivante en t\^ete du header de InputListener:

\begin{lstlisting}[caption={Include OIS}]
#include <OIS/OIS.h>
\end{lstlisting}

Bien s\^ur, vous pouvez aussi ajouter le r\'epertoire OIS \`{a} la liste des includes de votre IDE pour \'eviter d'avoir \`{a} le pr\'eciser dans le code.




























\section{Allons-y sans buffer}\footnote{Le tutorial du site de Ogre ''Frame Listeners and Unbuffered Input'' pr\'esente le point trait\'e ici d'une autre mani\`ere \href{http://www.ogre3d.org/tikiwiki/Basic+Tutorial+4}{Frame Listeners and Unbuffered Input}}
\subsection{Explications}
Dans le constructeur de notre frame listener, je vous ai dit que l'on avait mis les param\`etres concernant l'utilisation du buffer \`a false, car c'est l'objet de la derni\`ere partie de ce chapitre. Mais que signifie le fait d'utiliser ou non le buffer ?

Lorsque vous appuyez sur une touche, le clavier envoie un signal \`a l'ordinateur pour lui dire qu'une touche est actuellement press\'ee, en pr\'ecisant quelle touche est concern\'ee. Ce signal est envoy\'e tant que la touche reste enfonc\'ee.

De son cot\'e, notre programme effectue sa boucle infinie, rendant les images et faisant les calculs demand\'es. Supposons que vous appuyez sur une touche \`a un instant donn\'e. Lorsque l'ordinateur arrivera \`a l'instruction lui demandant de regarder ce qui se passe sur le clavier, il va voir qu'une touche est enfonc\'ee et cherchera \`a effectuer les op\'erations demand\'ees, et ceci tant que la touche reste enfonc\'ee. Mais il n'est pas possible pour l'ordinateur de faire seul la diff\'erence entre une touche enfonc\'ee et une touche qui vient d'\^etre enfonc\'ee.

Nous allons donc voir comment r\'egler ce probl\`eme ''\`a la main'', puis nous verrons l'utilisation du buffer, qui constitue une autre fa\c{c}on de traiter l'entr\'ee.

\subsection{Cr\'eation du frame listener}

Avant de passer \`a la suite, r\'eimpl\'ementez la m\'ethode createFrameListener() pr\'esente dans ExampleApplication dans la classe PremiereApplication en ajoutant le prototype et la d\'efinition :

\begin{lstlisting}[caption={PremiereApplication::createFrameListener}]
void PremiereApplication::createFrameListener()
{
    //creation du framelistener en utilisant le ctor prepare plus tot
    mFrameListener= new InputListener(mWindow, mCamera, mSceneMgr, false, false, false);
    //signale a l objet root que ns avons un nv frame listener et qu il faudra l'appeler
    mRoot->addFrameListener(mFrameListener);
}
\end{lstlisting}

Le root est l'\'el\'ement de base de l'application Ogre qui s'occupe notamment de g\'erer les frame listeners, nous le reverrons plus tard en approfondissant le fonctionnement du moteur.
 









\subsection{D\'eplacer la cam\'era}


Tout d'abord, nous allons consid\'erer le d\'eplacement de cam\'era, pour lequel nous n'avons pas besoin de savoir si la touche vient d'\^etre appuy\'ee : c'est simplement son \'etat actuel qui compte.

Premi\`erement, il nous faut r\'ecup\'erer l'\'etat actuel du clavier et de la souris. Localisez la m\'ethode frameRenderingQueued() de votre InputListener et ins\'erez-y ceci :


\begin{lstlisting}[caption={}]
if(mMouse)
    mMouse->capture();
if(mKeyboard)
    mKeyboard->capture();
\end{lstlisting}

Ces deux lignes permettent de mettre \`a jour nos objets pour obtenir le nom des touches enfonc\'ees.\newline

V\'erifions d'abord si la touche Echap est utilis\'ee, auquel cas nous quitterons l'application.


\begin{lstlisting}[caption={}]
if(mKeyboard->isKeyDown(OIS::KC_ESCAPE))
    return false;
\end{lstlisting}

Nous devons ensuite mettre \`a jour la valeur de mMouvement, qui sera la distance parcourue par la cam\'era si une direction est choisie. Comme le nombre d'images par seconde est variable, nous utilisons la propri\'et\'e timeSinceLastFrame de l'\'ev\'enement, multipli\'ee par la vitesse de la cam\'era. Le produit de la vitesse par le temps \'ecoul\'e nous donne donc la distance parcourue.

J'ai aussi cr\'e\'e un vecteur dans lequel nous allons enregistrer les d\'eplacements \`a effectuer. En effet, on peut utiliser plusieurs touches en m\^eme temps, il faut donc additionner les directions demand\'ees, et les conserver pour d\'eplacer la cam\'era en une seule fois.


\begin{lstlisting}[caption={}]
Ogre::Vector3 deplacement = Ogre::Vector3::ZERO;
mMouvement = mVitesse * evt.timeSinceLastFrame;
\end{lstlisting}

Nous allons utiliser les fl\`eches du clavier et les touches Z, S, Q, D pour nous d\'eplacer ; j'ai aussi impl\'ement\'e les touches fl\'ech\'ees, qui sont une configuration alternative pour le d\'eplacement. Il faut donc v\'erifier si les touches qui nous int\'eressent sont enfonc\'ees :


\begin{lstlisting}[caption={}]
// La touche A d'un clavier QWERTY correspond au Q sur un AZERTY
if(mKeyboard->isKeyDown(OIS::KC_LEFT) || mKeyboard->isKeyDown(OIS::KC_A)) 
    deplacement.x -= mMouvement;

if(mKeyboard->isKeyDown(OIS::KC_RIGHT) || mKeyboard->isKeyDown(OIS::KC_D))
    deplacement.x += mMouvement;
    
// W correspond au Z du AZERTY
if(mKeyboard->isKeyDown(OIS::KC_UP) || mKeyboard->isKeyDown(OIS::KC_W)) 
    deplacement.z -= mMouvement;

if(mKeyboard->isKeyDown(OIS::KC_DOWN) || mKeyboard->isKeyDown(OIS::KC_S))
    deplacement.z += mMouvement;
\end{lstlisting}

Attention aux signes ! Vous devez respecter ce que nous avons vu dans le chapitre sur les d\'eplacements !\footnote{hein? de quoi parle t il?}

Le d\'eplacement de la cam\'era fonctionne, il ne manque plus que la rotation de celle-ci. Il nous suffit pour cela de r\'ecup\'erer le d\'eplacement relatif depuis la derni\`ere fois que la souris a boug\'e (depuis le dernier appel \`a frameRenderingQueued() donc).

Pour retrouver cette valeur, on passe successivement par les attributs suivants :
\begin{itemize}
\item le mouseState contenu dans l'objet souris, contenant diverses informations sur l'\'etat de la souris ;
\item l'axe que l'on d\'esire observer : ici, ce sera X ou Y pour le yaw ou le pitch ;
\item le d\'eplacement relatif de la souris suivant cet axe.
\end{itemize}

Maintenant, occupons-nous du mouvement de la souris. Pour r\'ecup\'erer le d\'eplacement de celle-ci, nous devons r\'ecup\'erer son \'etat, comme indiqu\'e dans le code suivant.


\begin{lstlisting}[caption={}]
const OIS::MouseState &mouseState = mMouse->getMouseState();
\end{lstlisting}

\`A partir de cette r\'ef\'erence on peut notamment r\'ecup\'erer le d\'eplacement de la souris depuis la derni\`ere image, en appelant l'axe X ou Y puis l'attribut rel.


\begin{lstlisting}[caption={}]
mRotationX = Degree(-mouseState.Y.rel * mVitesseRotation);
mRotationY = Degree(-mouseState.X.rel * mVitesseRotation);
\end{lstlisting}

Il faut particuli\`erement faire attention aux axes et aux signes. Je consid\`ere que mRotationX (respectivement mRotationY) correspond \`a la rotation autour de l'axe X (respectivement Y), c'est-\`a-dire lorsque je d\'eplace ma souris en avant ou en arri\`ere (respectivement \`a gauche ou \`a droite). Or, le d\'eplacement vers l'avant ou l'arri\`ere de la souris correspond \`a son axe Y, c'est pour \c{c}a que je demande l'axe Y de la souris pour trouver la rotation autour de X dans l'espace 3D.

On rajoute une multiplication par la vitesse de rotation voulue et on convertit le tout en degr\'es, sinon le mouvement est bien trop rapide.

Enfin, on appelle les m\'ethodes de rotation et de d\'eplacement de la cam\'era :

\begin{lstlisting}[caption={}]
mCamera->yaw(mRotationY);
mCamera->pitch(mRotationX);
mCamera->moveRelative(deplacement);
\end{lstlisting}

La derni\`ere ligne, comme vous le remarquez, d\'eplace la cam\'era par rapport \`a son rep\`ere local, ce qui \'evite de faire la transformation de la variable deplacement \`a la main. Il est aussi possible de demander un d\'eplacement par rapport au rep\`ere absolu avec Camera::move().


















\subsection{Et avec un noeud de sc\`ene ?}

J'en profite pour vous montrer comment on aurait proc\'ed\'e pour d\'eplacer un noeud de sc\`ene par exemple, qui utilise la m\'ethode translate().

Les deux lignes suivantes sont \'equivalentes :


\begin{lstlisting}[caption={}]
node->translate(deplacement, TS_LOCAL);
node->translate(node->getOrientation() * deplacement, TS_PARENT);
\end{lstlisting}


La premi\`ere ligne est tr\`es similaire \`a celle utilis\'ee pour la cam\'era, il suffit de pr\'eciser que l'on se d\'eplace par rapport au rep\`ere local du noeud de sc\`ene.

La seconde solution indique un d\'eplacement relatif au noeud parent, mais utilise le quaternion retourn\'e par la m\'ethode getOrientation() multipli\'e par le vecteur de d\'eplacement pour obtenir la direction souhait\'ee dans ce rep\`ere. En pratique, on utilisera seulement la premi\`ere ligne, plus courte et plus propre dans le code.







\subsection{}
Mini-TP : cr\'eer un interrupteur

Pour g\'erer un \'ev\'enement qui ne doit arriver qu'une fois lorsque la touche est appuy\'ee, il y a une pr\'ecaution suppl\'ementaire \`a prendre. Je vous ai dit plus haut que votre ordinateur ne retenait pas l'\'etat dans lequel se trouvait votre clavier ou votre souris \`a l'image pr\'ec\'edente. Cependant, rien ne nous emp\^eche de le faire nous-m\^emes !

\`A titre d'exemple, disons que l'on veut utiliser la touche T pour allumer et \'eteindre la lumi\`ere de notre sc\`ene. Il va donc falloir v\'erifier \`a chaque image si la touche T est enfonc\'ee, et si en plus ce n'\'etait pas d\'ej\`a le cas \`a l'image pr\'ec\'edente. Pour cela, on utilisera l'attribut mToucheAppuyee de notre classe InputListener.

Un indice: le SceneManager poss\`ede une m\'ethode getLight() qui permet de r\'ecup\'erer un pointeur sur une lumi\`ere \`a partir du nom de celle-ci...

\`A vos claviers ! La r\'eponse se trouve juste apr\`es.



\begin{lstlisting}[caption={Capture de l'\'etat ponctuel d'une touche}]
bool etatTouche = mKeyboard->isKeyDown(OIS::KC_T);
if(etatTouche && !mToucheAppuyee)
{
    Ogre::Light *light = mSceneMgr->getLight("lumiere1");
    light->setVisible(!light->isVisible());
}
mToucheAppuyee = etatTouche;
\end{lstlisting}





Tout d'abord, je r\'ecup\`ere l'\'etat actuel de ma touche T dans une variable locale. Je v\'erifie si la touche est actuellement enfonc\'ee et si elle ne l'\'etait pas d\'ej\`a \`a l'aide de l'attribut mToucheAppuyee. Si ma condition est v\'erifi\'ee, je r\'ecup\`ere ma lumi\`ere, et je change son \'etat (visible ou non).

Enfin, j'enregistre l'\'etat actuel de ma touche T dans mToucheAppuyee, en pr\'evision de la prochaine image!







\subsection{Code}


\begin{lstlisting}[caption={InputListener.h}]
#include "ExampleFrameListener.h"

//nous utiliserons OIS pour gérer les entrées de l'utilisateur
#include <OIS/OIS.h>

//la classe ExampleFrameListener ExampleApplication met déjà en oeuvre une gestion des entrées eet attend un ExampleFrameListener
//ExampleFrameListener s'occupe aussi de construire les objets nécessaires à l'écoute des entrées
class InputListener : public ExampleFrameListener
{
    public:
        InputListener(RenderWindow* win, Camera* cam, SceneManager *sceneMgr, 
                        bool bufferedKeys = false, bool bufferedMouse = false, 
                        bool bufferedJoy = false);
        
        //nous allons juste devoir redefinir frameRenderingQueued() pour implementer notre propre gestion des entrees a la place de celle prevue par ExampleFrameListener.
        virtual bool frameRenderingQueued(const FrameEvent& evt);

        private:
            Ogre::SceneManager *mSceneMgr;
            Ogre::Camera *mCamera;
            
            bool mContinuer;
            bool mToucheAppuyee;

            Ogre::Real mMouvement;
            Ogre::Real mVitesse;
            Ogre::Real mVitesseRotation;

            Ogre::Radian mRotationX;
            Ogre::Radian mRotationY;
};
\end{lstlisting}


Dans la m\'ethode InputListener::frameRenderingQueued, les touches press\'ees et les mouvements de la souris permettent soit le d\'eplacement de la t\^ete soit le d\'eplacement de la cam\'era selon les lignes qui en fin de m\'ethodes sont comment\'ees.
\begin{lstlisting}[caption={InputListener.cpp}]
#include <OIS/OIS.h>
#include "InputListener.h"



InputListener::InputListener(RenderWindow* win, Camera* cam, SceneManager *sceneMgr,
                                bool bufferedKeys, bool bufferedMouse, bool bufferedJoy) 
    : ExampleFrameListener(win, cam, bufferedKeys, bufferedMouse, bufferedJoy)

    {
        mCamera = cam;
        mSceneMgr = sceneMgr;
        mVitesse = 100;
        mVitesseRotation = 0.3;
        mToucheAppuyee = false;
    }



bool InputListener::frameRenderingQueued(const FrameEvent& evt)
{
    //ces lignes permettent la mise à jour de nos objets pour obtenir le nom des touches enfoncées
   if(mMouse){
       mMouse->capture();
   }
   if(mKeyboard){
       mKeyboard->capture();
   }
   
   
   if(mKeyboard->isKeyDown(OIS::KC_ESCAPE)){
       mContinuer = false;
   }
   else{
       mContinuer= true;
   }
   
   Ogre::Vector3 deplacement = Ogre::Vector3::ZERO;
   mMouvement = mVitesse * evt.timeSinceLastFrame;
   
   
    // La touche A d un clavier QWERTY correspond au Q sur un AZERTY
    if ( mKeyboard->isKeyDown(OIS::KC_LEFT) || mKeyboard->isKeyDown(OIS::KC_A) ){
        deplacement.x -= mMouvement;
    }
    
    if ( mKeyboard->isKeyDown(OIS::KC_RIGHT) || mKeyboard->isKeyDown(OIS::KC_D) ){
        deplacement.x += mMouvement;
    }
    

    // W correspond au Z du AZERTY
    if ( mKeyboard->isKeyDown(OIS::KC_UP) || mKeyboard->isKeyDown(OIS::KC_W)){
        deplacement.z -= mMouvement;
    }
    
    if ( mKeyboard->isKeyDown(OIS::KC_DOWN) || mKeyboard->isKeyDown(OIS::KC_S)){
        deplacement.z += mMouvement;
    }
    
    //*
    const OIS::MouseState &mouseState = mMouse->getMouseState();
    mRotationX = Degree(-mouseState.Y.rel * mVitesseRotation);
    mRotationY = Degree(-mouseState.X.rel * mVitesseRotation);
    
    //pour que la camera bouge selon les touches pressees et le mouvement de la souris
    //mCamera->yaw(mRotationY);
    //mCamera->pitch(mRotationX);        
    //mCamera->moveRelative(deplacement);
    
    //pour que le noeud "nodeTete" bouge selon les touches pressees et le mouvement de la souris
    mSceneMgr->getSceneNode("nodeTete")->yaw(mRotationY);
    mSceneMgr->getSceneNode("nodeTete")->pitch(mRotationX);
    mSceneMgr->getSceneNode("nodeTete")->translate(deplacement, Ogre::Node::TS_LOCAL);
    
    return mContinuer;
}
\end{lstlisting}


\begin{lstlisting}[caption={PremiereApplication.h}]
using namespace std;

#include <ExampleApplication.h>
#include <OgreMovableObject.h>

#include "InputListener.h"


class PremiereApplication : public ExampleApplication
{
    public:
        void createScene();
        void createCamera();
        void createViewports();

        void createFrameListener();
        
        void createLux(std::string, MovableObject *);
};
\end{lstlisting}


\begin{lstlisting}[caption={PremiereApplication.cpp}]
#include "PremiereApplication.h"



void PremiereApplication::createFrameListener()
{
    mFrameListener = new InputListener(mWindow, mCamera, mSceneMgr, false, false, false);
    
    //root est l'élément de base de l'application Ogre qui s'occupe notamment de gérer les frames listeners
    mRoot -> addFrameListener(mFrameListener);
}


void PremiereApplication::createScene()
{
    //creation d une entite
    Entity *head= mSceneMgr->createEntity("Tete", "ogrehead.mesh" );
    
    //creation d un noeud
    SceneNode *node= mSceneMgr->getRootSceneNode()->createChildSceneNode("nodeTete" , Vector3::ZERO, Quaternion::IDENTITY);
    
    node->yaw(Radian(Math::PI));
    node->yaw(Radian(Math::PI));

    //setPosition place le noeud aux coord passees en parametres
    Vector3 position = Vector3(30.0, 50.0, 0.0);
    node->setPosition(position);

    node->setPosition(30.0, 50.0, 0.0); 
    /*equivalent a
    Vector3 position = Vector3(30.0, 50.0, 0.0);
    node->setPosition(position);
    */

    //deplace le noeud par rapport a sa position actuelle
    node->translate(-30.0, 50.0, 0.0); //par defaut la trnslt se fait par rap a TS_WORLD
   
    //attachement de l entite au noeud
    node->attachObject(head);

    //creation d un plan
    Plane plan(Vector3::UNIT_Y, 0);

    //creation d un mesh cad l objet 3d visible ds la scene
    MeshManager::getSingleton().createPlane("sol",
                ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME,
                plan, 500, 500, 10, 10, true, 1, 1, 1, Vector3::UNIT_Z); 

    //entite qui representera le plan
    Entity *ent= mSceneMgr->createEntity("EntiteSol", "sol");

    //ajout du materiau a l entite
    ent->setMaterialName("Examples/GrassFloor");//texture de pelouse
    /*les differents materiaux sont sous /media/materials/scritps, par ex:
    ent->setMaterialName("Examples/WaterStream");//texture d eau animee*/

    //creation d un noeud
    node = mSceneMgr->getRootSceneNode()->createChildSceneNode();
    node->attachObject(ent);

    createLux("ponctuelle", head);//lumiere ponctuelle
    //createLux("directionnelle", head);//lumiere directionnelle
    //createLux("spot", head);//lumiere projecteur

}

/*
cree une lumiere selon le parametre passe:
    createLux("ponctuelle"); -> lumiere ponctuelle
    createLux("directionnelle"); -> lumiere directionnelle
    createLux("spot"); -> lumiere projecteur

une lumiere noire est cree au debut de la methode

une ombre est cree en fin de methode
*/
void PremiereApplication::createLux(std::string prmLightType, MovableObject * prmEnt)
{
    //application d une couleur noire
    mSceneMgr->setAmbientLight(ColourValue(0.0, 0.0, 0.0)); 

    //definition d une lumiere 
    Light *light= mSceneMgr->createLight("lumiere1");

    if (prmLightType == "ponctuelle")
    {
        //definition du type de lumiere
        light->setType(Light::LT_POINT);//lumiere ponctuelle

        //definition de la position de la lumiere
        light->setPosition(-100, 200, 100);
    }
    else if (prmLightType == "directionnelle")
    {
        light->setType(Light::LT_DIRECTIONAL);//lumiere directionnelle
        light->setDirection(10.0, -20.0, -5);//vecteur directeur de la lumiere directionnelle

        //definition de la position de la lumiere
        light->setPosition(-100, 200, 100);
    }
    else
    {
        light->setType(Light::LT_SPOTLIGHT);//lumiere directionnelle
        light->setDirection(0.0, -1, 1);//vecteur directeur de la lumiere directionnelle
        light->setSpotlightRange(Degree(30), Degree(60), 1.0);
    }

    //definition des couleur des lumieres diffuse
    light->setDiffuseColour(1.0, 0.7, 0.1);
    //et speculaire
    light->setSpecularColour(1.0, 0.7, 0.1);

    //ombre
    //activation de la projection des ombres
    light->setCastShadows(true);
    prmEnt->setCastShadows(true);

    //activation des ombres
    mSceneMgr->setShadowTechnique(Ogre::SHADOWTYPE_STENCIL_ADDITIVE);
}

/*definit la position de notre point de vue*/
void PremiereApplication::createCamera()
{
    //creation de la camera
    mCamera = mSceneMgr->createCamera("Ma Camera");

    //position de la camera
    mCamera->setPosition(Vector3(-100.0, 150.0, 200.0));

    //permet de determiner le point de la scene que regarde notre camera
    mCamera->lookAt(Vector3(0.0, 100.0, 0.0));

    //definition des distances de near clip et de far clip, qui
    //sont les distances minimale et maximale auxquelles doit se
    //trouver un objet pour être affichr à l'écran.
    mCamera->setNearClipDistance(1);
    mCamera->setFarClipDistance(1000);
}

void PremiereApplication::createViewports()
{
    //la creation du Viewport, appelee par la fenetre et prenant en parametre la
    //camera concernee, le premier parametre est la camera de laqll le contenu
    //du viewport sera rendu, ce paramatre est le seul obligatoire
    Viewport *vue = mWindow->addViewport(mCamera);
    //Viewport *vue = mWindow->addViewport(mCamera, 0, 0, 0, 0.8, 0.8);

    //Grace a ce Viewport nouvellement cree, nous allons faire coincider
    //le rapport largeur / hauteur de notre camera avec celui du
    //Viewport, pour avoir une image non deformee
    mCamera->setAspectRatio(Real(vue->getActualWidth()) /  Real(vue->getActualHeight()));

    //on definit ici la couleur de fond
    vue->setBackgroundColour(ColourValue(0.0, 0.0, 1.0));     //bleu
    //vue->setBackgroundColour(ColourValue(0.980, 0.502, 0.447)); //saumon

   // creation d'un viewport dans le coin bas gauche
   //les parametres autres que le premier sont obligatoires pour la definition
   //de plusieurs viewport
   Viewport* vue2 = mWindow->addViewport(mCamera, 1, 0, 0.8, 0.2, 0.2);
   vue2->setBackgroundColour(ColourValue(0.561, 0.737, 0.561 ));  //darkseagreen
}


\end{lstlisting}






Puisque nous avons ajout\'e un fichier source il est n\'ecessaire de modifier le fichier CMakeLists.txt tel que suit:

\begin{lstlisting}[caption={CMakeLists.txt}]
project(helloworld)
cmake_minimum_required(VERSION 2.6)

set(CMAKE_MODULE_PATH "/usr/share/OGRE/cmake/modules")


# Il faut indiquer a cmake ou se trouvent les includes en question
#include_directories ("/home/adkoba/Workspace/ogre_src_v1-8-1/Samples/Common/include")
include_directories ("include")

# Bien sur, pour compiler Ogre, il faut le chercher, et definir le repertoire contenant les includes.
find_package(OGRE REQUIRED)
include_directories (${OGRE_INCLUDE_DIRS})

# L'exemple depend aussi de OIS, une lib pour gerer la souris, clavier, joystick...
find_package(OIS REQUIRED)

# On definit les sources qu'on veut compiler
SET( SOURCES
  src/InputListener.cpp  
  src/PremiereApplication.cpp
  src/main.cpp
)

# On les compile
add_executable (
  premiereapp ${SOURCES}
)

# Et pour finir, on lie l'excutable avec les librairies que find_package nous a gentillement trouve.
target_link_libraries(premiereapp ${OGRE_LIBRARY} ${OIS_LIBRARY} -lboost_system)

set( RESOURCES_FILE
  media/
  plugins/
  resources/ogre.cfg
  resources/plugins.cfg
  resources/resources.cfg
)

# do the copying
foreach( file_i ${RESOURCES_FILE})
    add_custom_command(
      TARGET premiereapp
      POST_BUILD
      COMMAND cp -R ${CMAKE_SOURCE_DIR}/${file_i} ${CMAKE_BINARY_DIR}
      COMMENT "copy file ${file_i}"
      )
endforeach( file_i )
\end{lstlisting}

Comme nous pouvons le voir nous avons juste modifi\'e la liste des sources du projet












\section{Avec buffer, c'est plus simple ?}

La m\'ethode pr\'esent\'ee ci-avant pour contr\^oler si une touche vient ou non d'\^etre appuy\'ee fonctionne mais est peu pratique si on doit surveiller quinze touches.

Heureusement, OIS a pens\'e \`a tout, nous allons donc voir une autre fa\c{c}on de faire ce que l'on vient juste d'\'ecrire. On va commencer comme pr\'ec\'edemment par le d\'eplacement de la cam\'era, puis on verra comment g\'erer notre interrupteur.


\subsection{Mise en place}


Nous allons commencer par activer l'utilisation du buffer pour la souris et le clavier lors de la construction de notre frame listener. Il suffit pour cela de mettre les param\`etres correspondants \`a true.


\begin{lstlisting}[caption={Activation du buffer pour la souris et le clavier}]
void PremiereApplication::createFrameListener()
{
    mFrameListener= new InputListener(mWindow, mCamera, mSceneMgr, true, true, false);    mRoot->addFrameListener(mFrameListener);
}
\end{lstlisting}


C'est quasiment tout , il va simplement falloir rajouter deux petites lignes dans le constructeur pour que tout soit pr\^et.

Afin d'utiliser le buffer, il faut fournir un objet (un ''\'ecouteur'' d\'erivant d'une des classes OIS::***Listener selon le p\'eriph\'erique \`a \'ecouter) qui sera celui qui recevra les \'ev\'enements du type ''cette touche vient d'\^etre appuy\'ee, que dois-je faire ?''. Pour cela, OIS fournit une m\'ethode pour chacun de trois p\'eriph\'eriques d'entr\'ee (clavier, souris, joystick) :


\begin{itemize}
\item virtual void OIS::Mouse::setEventCallback(OIS::MouseListener* mouseListener);
\item  virtual void OIS::Keyboard::setEventCallback(OIS::KeyListener* keyListener);
\item  virtual void OIS::JoyStick::setEventCallback(OIS::JoyStickListener* joystickListener);
\end{itemize}

Cette m\'ethode prend donc en param\`etre un pointeur sur un listener du p\'eriph\'erique que vous voulez utiliser. Nous allons donc rajouter deux classes m\`eres \`a notre InputListener : OIS::MouseListener et OIS::KeyListener. Modifiez donc la d\'eclaration de la classe InputListener :

\begin{lstlisting}[caption={Classes m\`eres pour gestion des Listeners}]
class InputListener : public ExampleFrameListener, OIS::KeyListener, OIS::MouseListener
\end{lstlisting}

Dans le constructeur, vous pouvez maintenant ins\'erer les deux lignes suivantes (mMouse et mKeyboard sont d\'eclar\'ees dans ExampleFrameListener) :

\begin{lstlisting}[caption={Enregistrement des listener}]
mMouse->setEventCallback(this);
mKeyboard->setEventCallback(this);
\end{lstlisting}

Vous ne pouvez enregistrer qu'un seul \'ecouteur par p\'eriph\'erique d'entr\'ee. En cas d'appels multiples \`a la m\'ethode setEventCallback(), c'est le dernier appel qui d\'efinit l'\'ecouteur \`a utiliser. Pour que diff\'erents objets re\c{c}oivent les \'ev\'enements, il faudra donc les redistribuer \`a partir de l'\'ecouteur receveur.

Au chapitre des modifications, supprimez les anciens attributs d'InputListener et mettez ceux-ci :

\begin{lstlisting}[caption={Attributs d'InputListener}]
private:
    Ogre::SceneManager *mSceneMgr;
    bool mContinuer;
    Ogre::Vector3 mMouvement;
    Ogre::Real mVitesse;
    Ogre::Real mVitesseRotation;
\end{lstlisting}

En initialisant ces attributs, votre constructeur devrait maintenant ressembler \`a ceci :

\begin{lstlisting}[caption={Constructeur d'InputListener}]
InputListener(RenderWindow* win, Camera* cam, SceneManager *sceneMgr, bool bufferedKeys = false, bool bufferedMouse = false, bool bufferedJoy = false )   : ExampleFrameListener(win, cam, bufferedKeys, bufferedMouse, bufferedJoy)
{
    mSceneMgr = sceneMgr;
    mContinuer = true;  //permettra d'enregistrer l'appui sur la touche Echap
    mMouvement = Ogre::Vector3::ZERO;//vecteur de la direction ds lqulle se d\'eplacer
    mVitesse = 100;
    mVitesseRotation = 0.2;//facteur multiplicatif pr ajuster la vitesse de la cam 
    mMouse->setEventCallback(this);
    mKeyboard->setEventCallback(this);
}
\end{lstlisting}

L'attribut mContinuer permettra d'enregistrer l'appui sur la touche Echap, mMouvement sera le vecteur de la direction dans laquelle on doit se d\'eplacer et mVitesseRotation un facteur multiplicatif permettant d'ajuster la vitesse de rotation de la cam\'era.

On met \`a jour la valeur de retour de la m\'ethode frameRenderingQueued().

\begin{lstlisting}[caption={}]
bool InputListener::frameRenderingQueued(const Ogre::FrameEvent& evt)
{
    if(mMouse)
        mMouse->capture();
    if(mKeyboard)
        mKeyboard->capture();

    return mContinuer;
}
\end{lstlisting}

Enfin, il y a des m\'ethodes virtuelles pures \`a r\'eimpl\'ementer dans notre classe. Ces m\'ethodes seront appel\'ees lors de l'\'ev\'enement correspondant sur le clavier (touche enfonc\'ee ou rel\^ach\'ee) ou sur la souris (bouton appuy\'e ou rel\^ach\'e, d\'eplacement). De m\^eme que les m\'ethodes des frame listeners d'Ogre, elles renvoient un bool\'een que l'on utilisera pour savoir si l'on doit interrompre le programme.

Ajoutons donc les prototypes dans notre header et un simple retour de valeur dans le corps des m\'ethodes pour commencer.

Contrairement aux m\'ethodes des frame listeners, la valeur de retour ne d\'etermine pas si l'on doit continuer ou non l'ex\'ecution. C'est pour cela que l'on devra passer par l'attribut mContinuer pour surveiller l'appui sur la touche Echap.


\begin{lstlisting}[caption={M\'ethodes virtuelles appel\'ees lors d'un \'ev\`enement sur un p\'eriph\'erique}]
bool InputListener::mouseMoved(const OIS::MouseEvent &e)
{
    return true;
}

bool InputListener::mousePressed(const OIS::MouseEvent &e, OIS::MouseButtonID id)
{
    return true;
}

bool InputListener::mouseReleased(const OIS::MouseEvent &e, OIS::MouseButtonID id)
{
    return true;
}

bool InputListener::keyPressed(const OIS::KeyEvent &e)
{
    return true;
}

bool InputListener::keyReleased(const OIS::KeyEvent &e)
{
    return true;
}
\end{lstlisting}

On commence par impl\'ementer la touche Echap. Si elle est appuy\'ee, on passe simplement l'attribut mContinuer \`a false.

\begin{lstlisting}[caption={Impl\'ementation de l'appuie sur ECHAP}]
bool InputListener::keyPressed(const OIS::KeyEvent &e)
{
    switch(e.key)
    {
        case OIS::KC_ESCAPE:
            mContinuer = false;
            break;
    }

    return mContinuer;
}
\end{lstlisting}

On g\`ere ensuite l'appui sur les touches de d\'eplacement en modifiant les composantes de mMouvement en fonction de la touche. On va aussi multiplier la vitesse de d\'eplacement par deux lorsque l'on appuie sur la touche majuscule gauche.

\begin{lstlisting}[caption={Impl\'ementation de l'appuie sur les touches de d\'eplacement}]
bool InputListener::keyPressed(const OIS::KeyEvent &e)
{
    switch(e.key)
    {
        case OIS::KC_ESCAPE:
            mContinuer = false;
            break;
        case OIS::KC_W:
            mMouvement.z -= 1;
            break;
        case OIS::KC_S:
            mMouvement.z += 1;
            break;
        case OIS::KC_A:
            mMouvement.x -= 1;
            break;
        case OIS::KC_D:
            mMouvement.x += 1;
            break;
        case OIS::KC_LSHIFT:
            mVitesse *= 2;
            break;
    }

    return mContinuer;
}
\end{lstlisting}

Enfin, dans la m\'ethode keyReleased, on va ''retirer'' la composante que l'on ajoute lors de l'appui sur une touche. Le code est donc semblable, seuls les signes changent.

\begin{lstlisting}[caption={}]
bool InputListener::keyReleased(const OIS::KeyEvent &e)
{
    switch(e.key)
    {
        case OIS::KC_W:
            mMouvement.z += 1;
            break;
        case OIS::KC_S:
            mMouvement.z -= 1;
            break;
        case OIS::KC_A:
            mMouvement.x += 1;
            break;
        case OIS::KC_D:
            mMouvement.x -= 1;
            break;
        case OIS::KC_LSHIFT:
            mVitesse /= 2;
            break;
    }

    return true;
}
\end{lstlisting}

Maintenant que l'on g\`ere correctement l'\'evolution de nos variables de mouvement et de vitesse de d\'eplacement, il faut \'ecrire le d\'eplacement de la cam\'era dans la m\'ethode frameRenderingQueued().

\begin{lstlisting}[caption={Impl\'ementation du d\'eplacement de la cam\'era dans la m\'ethode frameRenderingQueued}]
virtual bool frameRenderingQueued(const FrameEvent& evt)
{
    if(mMouse)
        mMouse->capture();

    if(mKeyboard)
        mKeyboard->capture();

    Ogre::Vector3 deplacement = Ogre::Vector3::ZERO;
    deplacement = mMouvement * mVitesse * evt.timeSinceLastFrame;
    mCamera->moveRelative(deplacement);

    return mContinuer;
}
\end{lstlisting}

Pour la rotation de la cam\'era, tout se passe dans la m\'ethode mouseMoved(), dont l'\'ev\'enement re\c{c}u en param\`etre contient l'\'etat de la souris, permettant comme pr\'ec\'edemment de retrouver le d\'eplacement relatif de la souris.

On multiplie cette valeur relative par la vitesse de rotation, on fait attention aux signes, et voici ce qu'on obtient :

\begin{lstlisting}[caption={Impl\'ementation de la rotation de la cam\'era dans la m\'ethode mouseMoved}]
bool InputListener::mouseMoved(const OIS::MouseEvent &e)
{
    mCamera->yaw(Ogre::Degree(-mVitesseRotation * e.state.X.rel));
    mCamera->pitch(Ogre::Degree(-mVitesseRotation * e.state.Y.rel));

    return true;
}
\end{lstlisting}

Vous pouvez maintenant compiler et ex\'ecuter votre application ; les commandes de d\'eplacement sont maintenant g\'er\'ees enti\`erement par notre classe InputListener, n'h\'esitez donc pas \`a adapter les variables initialis\'ees dans le constructeur si vous voulez acc\'el\'erer ou ralentir les mouvements par exemple.\newline

Cette m\'ethode de gestion des entr\'ees permet donc de g\'erer plus facilement l'appui ponctuel sur une touche, tout en conservant une gestion simple des touches qui peuvent rester enfonc\'ees (pour le d\'eplacement ici).

Gardez cependant bien \`a l'esprit qu'\textbf{il ne peut y avoir qu'un seul \'ecouteur par p\'eriph\'erique d'entr\'ee} et qu'il faudra donc penser \`a rapporter l'appui sur les touches \`a des \'ecouteurs annexes lorsque votre application grossira, sinon vous allez vite vous retrouver avec un code lourd et mal organis\'e.\newline

Dans ce chapitre, nous avons vu comment g\'erer nous-m\^emes les entr\'ees de l'utilisateur avec la biblioth\`eque OIS, ainsi que le principe des frame listeners, qui nous ont ici \'et\'e bien utiles alors que nous n'avons pas encore vu le fonctionnement de la boucle de rendu.

Le prochain chapitre promet d'\^etre int\'eressant : nous allons en effet utiliser le module de terrain d'Ogre qui a \'et\'e refait dans la version 1.7 et qui offre une gestion beaucoup plus optimis\'ee des terrains par rapport aux versions pr\'ec\'edentes. Je n'en dis pas plus, on se retrouve de l'autre c\^ot\'e.


\subsection{Code}

Le CMakeLists.txt n'est pas modifi\'e par rapport \`a la gestion des entr\'ees sans buffer.


\begin{lstlisting}[caption={PremiereApplication::createFrameListener()}]
void PremiereApplication::createFrameListener()
{
    //activation du buffer pour la souris et le clavier
    mFrameListener = new InputListener(mWindow, mCamera, mSceneMgr, true, true, true);
    
    //root est l'élément de base de l'application Ogre qui s'occupe notamment de gérer les frames listeners
    mRoot -> addFrameListener(mFrameListener);
}

\end{lstlisting}














\begin{lstlisting}[caption={InputListener.h}]
#include "ExampleFrameListener.h"

//nous utiliserons OIS pour gérer les entrées de l'utilisateur
#include <OIS/OIS.h>

//la classe ExampleFrameListener ExampleApplication met déjà en oeuvre une gestion des entrées eet attend un ExampleFrameListener
//ExampleFrameListener s'occupe aussi de construire les objets nécessaires à l'écoute des entrées
class InputListener : public ExampleFrameListener, OIS::KeyListener, OIS::MouseListener
{
    public:
        InputListener(RenderWindow* win, Camera* cam, SceneManager *sceneMgr, 
                        bool bufferedKeys = false, bool bufferedMouse = false, 
                        bool bufferedJoy = false);
        
        //nous allons juste devoir redefinir frameRenderingQueued() pour implementer notre propre gestion des entrees a la place de celle prevue par ExampleFrameListener.
        virtual bool frameRenderingQueued(const FrameEvent& evt);
        
        //les 5 methodes suivantes sont des methodes virtuelles pures a reimplementer
        //ces methodes seront appelees lors de levenmnt correspondant, leur valeur de retour ne dit pas si on doit continuer ou pas, d'ou l'interet de mContinuer
        bool mouseMoved(const OIS::MouseEvent &e);      //evenmnt: la souris a bouge
        bool mousePressed(const OIS::MouseEvent &e, OIS::MouseButtonID id);//evenmnt: un bouton de la souris a ete presse
        bool mouseReleased(const OIS::MouseEvent &e, OIS::MouseButtonID id);//evenmnt: un bouton de la souris a ete relache 
        bool keyPressed(const OIS::KeyEvent &e);//evenmnt: un bouton a ete presse 
        bool keyReleased(const OIS::KeyEvent &e);//evenmnt: un bouton a ete relache 
        

        private:
            Ogre::SceneManager *mSceneMgr;
            Ogre::Camera *mCamera;
            
            //permettra d'enregistrer l'appuie sur ECHAP
            bool mContinuer;

            //vecteur de la direction ds lqll on doit bouger
            Ogre::Vector3 mMouvement;
            Ogre::Real mVitesse;
            
            //pour ajuster la vitesse de rotation de la souris
            Ogre::Real mVitesseRotation;

            Ogre::Radian mRotationX;
            Ogre::Radian mRotationY;
};

\end{lstlisting}













\begin{lstlisting}[caption={InputListener.cpp}]



#include <OIS/OIS.h>
#include "InputListener.h"



InputListener::InputListener(RenderWindow* win, Camera* cam, SceneManager *sceneMgr,
                                bool bufferedKeys, bool bufferedMouse, bool bufferedJoy) 
    : ExampleFrameListener(win, cam, bufferedKeys, bufferedMouse, bufferedJoy)
    {
        mCamera = cam;
        mSceneMgr = sceneMgr;
        
        mContinuer = true;//permettra l enregistrmnt de l appuie sur ECHAP
        mMouvement = Ogre::Vector3::ZERO;//sera le vct de la direection ds laqll on doit se deplacer
        
        mVitesse = 100;
        mVitesseRotation = 0.3;//fcteur multiplicatif pour ajuster la rotation de la camera
       
        //enregistrement d un ecouteur pour la souris et pour le clavier
        mMouse->setEventCallback(this);
        mKeyboard->setEventCallback(this);
    }



bool InputListener::frameRenderingQueued(const FrameEvent& evt)
{
    //ces lignes permettent la mise à jour de nos objets pour obtenir le nom des touches enfoncées
   if(mMouse){
       mMouse->capture();
   }
   if(mKeyboard){
       mKeyboard->capture();
   }
   
   //gestion du mouvement de la camera
   Ogre::Vector3 deplacement = Ogre::Vector3::ZERO;
   deplacement = mMouvement * mVitesse * evt.timeSinceLastFrame;
   mCamera->moveRelative(deplacement);
    
   return mContinuer;
}



//les 5 methodes suivantes sont des methodes virtuelles pures a reimplementer
//si la souris a bouge
bool InputListener::mouseMoved(const OIS::MouseEvent &e)
{    
    mCamera->yaw(Ogre::Degree(-mVitesseRotation * e.state.X.rel));
    mCamera->pitch(Ogre::Degree(-mVitesseRotation * e.state.Y.rel));
    
    return true;
}

//si une touche de la souris est pressee
bool InputListener::mousePressed(const OIS::MouseEvent &e, OIS::MouseButtonID id)
{
    return true;
}

//si une touche de la souris est relachee 
bool InputListener::mouseReleased(const OIS::MouseEvent &e, OIS::MouseButtonID id)
{
    return true;
}

//si une touche est pressee
bool InputListener::keyPressed(const OIS::KeyEvent &e)
{
    switch(e.key)
    {
        case OIS::KC_ESCAPE:
            mContinuer = false;
            break;
        case OIS::KC_W:
            mMouvement.z -= 1;
            break;
        case OIS::KC_S:
            mMouvement.z += 1;
            break;
        case OIS::KC_A:
            mMouvement.x -= 1;
            break;
        case OIS::KC_D:
            mMouvement.x += 1;
            break;
        case OIS::KC_LSHIFT:
            mVitesse *= 2;
            break;
    }
    
    return true;
}

//si une touche est relachee
bool InputListener::keyReleased(const OIS::KeyEvent &e)
{
    
    switch(e.key)
    {
        case OIS::KC_W:
            mMouvement.z += 1;
            break;
        case OIS::KC_S:
            mMouvement.z -= 1;
            break;
        case OIS::KC_A:
            mMouvement.x += 1;
            break;
        case OIS::KC_D:
            mMouvement.x -= 1;
            break;
        case OIS::KC_LSHIFT:
            mVitesse /= 2;
            break;
    } 
    
    return true;
}
\end{lstlisting}