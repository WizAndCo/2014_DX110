\chapter{Ins\'erer des objets dans la sc\`ene }

\section{les entit\'es}

\subsection{Une entit\'e c'est quoi}
Une entit\'e est l'ensemble des informations attach\'ees aux polygones constituant un objet 3D.\newline
Un Mesh \'etant l'ensemble des polygones constituant un objet 3D, une entit\'e est l'ensemble des informations attach\'ees \`{a} un Mesh:

\begin{itemize}
\item les vertices (sommets des polygones),
\item les textures,
\item un squelette si le modele est sujet \`{a} des animations
\item...\newline
\end{itemize}


Tous les objets solides qui apparaissent \`{a} l'\'ecran sont donc des entit\'es et sont repr\'esent\'es par une seule et m\^eme classe dans Ogre: la classe Entity.

\subsection{Le sceneManager}
C est au sceneManager que revient la t\^{a}che de cr\'eer tous les objets que peut contenir la sc\`ene (tous les mod\`eles, lumi\`eres, cam\'era et autres objets) et de nous permettre ensuite d'y acc\'eder.\newline
Par cons\'equent, l'insertion d'objets dans la sc\`ene passe toujours par lui (ou par l'un des \'el\'ements d\'ej\`{a} ins\'er\'es) et par les m\'ethodes qu'il propose pour cela.
Il en existe diverses variantes en fonction de la sc\`ene que l'on veut r\'ealiser; selon que celle-ci sera par exemple en int\'erieur ou en ext\'erieur, par exemple.

Toutes les applications Ogre doivent donc avoir un sceneManager pour pouvoir fonctionner, puisque c'est lui qui s'occupe de tout ! La classe ExampleApplication ne fait pas exception et poss\`ede donc un attribut msceneMgr, qui est un pointeur sur le sceneManager de l'application et qui nous permettra dans les parties suivantes d'agr\'ementer notre sc\`ene avec des objets.


\subsection{Cr\'eer une entit\'e}

L'entit\'e doit \^etre cr\'e\'ee par le sceneManager pour pouvoir \^etre ajout\'ee \`{a} la sc\`ene. La m\'ethode createEntity() permet de faire cela.
\begin{lstlisting}
Entity *head= msceneMgr->createEntity(''Tete'',''ogrehead.mesh'');
\end{lstlisting}\footnote{Pourquoi utilise t on -> pour appeler une m\'ethode d'une classe?}

\begin{itemize}
\item Le premier param\`etre est le nom que vous souhaitez donner au mesh. Ce nom doit \^etre unique!
\item Le second param\`etre est le nom du fichier que vous voulez charger. Notez l'extension.mesh, qui est le format de fichiers pour les mod\`eles reconnu par Ogre.
\end{itemize}




Le fichier sp\'ecifi\'e (avec le deuxi\`eme param\`etre) se trouve, accompagn\'e d'autres mod\`eles d'exemples, dans le dossier OgreSDK/media/models, qui doit \^etre correctement renseign\'e dans le fichier resources.cfg pour qu'Ogre puisse le trouver lors de l'ex\'ecution.\footnote{Mais \`a quoi sert ce fichier .mesh?}

Le mesh a \'et\'e ajout\'e \`{a} la sc\`ene mais il nous manque encore une chose avant de pouvoir l'afficher \`{a} l'\'ecran...













\section{Les Noeuds de la sc\`ene}



\subsection{L'utilit\'e des Noeuds}

Dans Ogre, lorsque l'on souhaite manipuler une entit\'e (un personnage, une lumi\`ere, une cam\'era...), les d\'eplacements que l'on veut effectuer se font par l'interm\'ediaire d'un noeud de sc\`ene, ou sceneNode.

Un sceneNode est un objet invisible auquel on va pouvoir attacher un nombre ind\'efini d'entit\'es, lesquelles deviennent solidaires de ce noeud et subissent donc les m\^eme transformations que lui. C'est donc une sorte de conteneur qui contient les informations de positionnement de chacune des entit\'es de la sc\`ene qui lui sont rattach\'ees.

Bien s\^ur on pourrait d\'eplacer nos entit\'es directement mais avec un noeud on pourra d\'eplacer en une fois toutes les entit\'es attach\'ees au noeud.

Quoi qu'il en soit, attacher chaque entit\'e \`{a} un noeud est primordial, sans quoi elle ne s'affichera pas dans votre sc\`ene!



\subsection{Cr\'eer un noeud}

Pour cr\'eer un noeud de sc\`ene on devra passer par un noeud d\'ej\`{a} existant, ce qui va nous permettre d'avoir des relations d'h\'eritage entre nos noeuds.\newline

On utilisera une m\'ethode d\'edi\'ee:

\begin{lstlisting}
sceneNode *noeudEnfant = noeudParent->createChildsceneNode(''enfant'', Vector3::ZERO, Quaternion::IDENTITY);
\end{lstlisting}


Mais comment fait-on pour le premier noeud\index{noeud} qu'on va cr\'eer ? Le noeud ''racine'' existe d\`es que le sceneManager est cr\'e\'e, c'est un noeud comme un autre avec les m\^eme \footnote{''les m\^eme'' faut il un ''s'' \`{a} ''m\^eme'' ?} m\'ethodes mais ce noeud est unique.\newline

Nous r\'ecup\'erons ce noeud racine de la sc\`ene  \`{a} l'aide de l'instance du sceneManager:
\begin{lstlisting}
sceneNode *node= msceneMgr->getRootsceneNode()->createChildsceneNode(''nodeTete'', Vector3::ZERO, Quaternion::IDENTITY);
\end{lstlisting}

La m\'ethode getRootsceneNode() nous permet de r\'ecup\'erer un pointeur sur le noeud racine unique de la sc\`ene. On appelle ensuite sa m\'ethode createChildsceneNode pour lui ajouter un nouveau noeud fils.

Notez qu'aucun des param\`etres de la m\'ethode n'est obligatoire, pour information:
\begin{itemize}
\item Le premier argument est le nom que vous voulez donner \`{a} votre noeud. Sur le m\^eme principe que les entit\'es ce nom pourra \^etre utilis\'e pour r\'ecup\'erer un pointeur vers le noeud en question. 
\item Le deuxi\`eme argument est la position initiale du noeud.
\item Le troisi\`eme argument est le quaternion avec lequel vous voulez initialiser votre noeud.
\end{itemize}
	

Sachez pour le moment qu'un quaternion est un objet math\'ematique qui permet de faire faire aux objets des rotations dans l'espace\footnote{Que des rotations?}. Quaternion::IDENTITY \footnote{comment \'ecrire Quaternion::IDENTITY de manière \'el\'egante?}lui dit de ne pas faire de rotation.\newline

Avec ce code en main, vous pouvez simplement attacher l'entit\'e pr\'ec\'edemment cr\'e\'ee au noeud avec la ligne suivante:

\begin{lstlisting}
node->attachObject(head);
\end{lstlisting}

En compilant, vous devriez voir la t\^ete d'un ogre au milieu de l'\'ecran. Vous pouvez d\'eplacer la cam\'era avec Z, S, Q, D et la souris pour voir ce que \c{c}a donne de plus pr\`es.



\subsection{Code}

\subsubsection{PremiereApplication.cpp}
\begin{lstlisting}[caption={PremiereApplication.cpp: Instanciation d'entit\'e}]
#include "PremiereApplication.h"

void PremiereApplication::createScene()
{
    //creation d une entite
    Entity *head= mSceneMgr->createEntity("Tete", "ogrehead.mesh" );
    
    //creation d un noeud
    SceneNode *node= mSceneMgr->getRootSceneNode( )->createChildSceneNode( "nodeTete " , Vector3::ZERO, Quaternion::IDENTITY);
    
    node->yaw(Radian(Math::PI));
    node->yaw(Radian(Math::PI));

    Vector3 position = Vector3(30.0, 50.0, 0.0);
    node->setPosition(position);

    node->setPosition(30.0, 50.0, 0.0); 
    node->translate(-30.0, 50.0, 0.0); 
    
    
    //attachement de l entite au noeud
    node->attachObject ( head );
}
\end{lstlisting}








\section{Cr\'eer un mesh}

Nous pouvons rajouter un sol \`{a} notre sc\`ene, pour cela nous allons cr\'eer nous-m\^emes\footnote{il faut un ''s'' \`a  nous-m\^emes?} un nouveau mesh. \'Etant donn\'e que nous n'avons besoin que d'un plan pour le sol, le mesh peut tr\`es simplement \^etre cr\'eer dans le code de notre application.



\subsection{Le mesh}

Il existe une classe Plane\footnote{de m\^eme que pour quaternion.entity marquer les noms de classe de manière \'el\'egante pour les discerner du texte serait bien} qui va nous permettre de g\'en\'erer... un plan qui repr\'esentera le sol.\footnote{En plus de la classe Plane, vous trouverez aussi des classes Box (pour les cubes) et Sphere qui fonctionnent sur le m\^eme principe.}\newline

Pour cr\'eer un plan nous appelons Plane avec les param\`etres suivants:
\begin{itemize}
\item le premier param\`etre permet de d\'efinir le vecteur normal au plan \`{a} cr\'eer (ici l'axe Y pour que notre plan soit horizontal).
\item le second param\`etre est la distance \`{a} l'origine de la sc\`ene dans le sens du vecteur normal  (ici, je mets 0 pour que mon mesh plan soit centr\'e). 
\end{itemize}

\begin{lstlisting}
	Plane plan(Vector3::UNIT_Y, 0);
\end{lstlisting}

Une fois le plan cr\'e\'e, il faut que l'on cr\'ee un mesh, c'est-\`{a}-dire l'objet 3D en lui-m\^eme (la repr\'esentation du plan) qui sera visible dans la sc\`ene.
Pour cela, on utilise le Mesh Manager, qui va s'occuper de cr\'eer les faces de notre mesh.

\begin{lstlisting}
MeshManager::getSingleton().createPlane(''sol'', ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME, plan, 500, 500, 1, 1, true, 1, 1, 1, Vector3::UNIT_Z);
\end{lstlisting}

Quelques explications sur cette ligne s'imposent. 
\begin{itemize}
\item Tout d'abord, la m\'ethode statique getSingleton() permet de r\'ecup\'erer un objet instanci\'e de fa\c{c}on unique, donc ici notre MeshManager.
\item Les deux premiers param\`etres correspondent respectivement au nom que l'on veut donner \`{a} notre mesh et au nom du groupe auquel on veut qu'il appartienne. 
\item Suivent ensuite le nom du plan \`{a} mod\'eliser, puis la largeur et la hauteur qu'il doit avoir, puis le nombre de subdivisions du plan dans ces deux sens. Plus il y a de subdivisions, plus il y a de polygones dans notre mesh. 
\item Le bool\'een suivant indique que les normales sont perpendiculaires au plan.
\item Les trois param\`etres suivants sont le nombre de textures que l'on va pouvoir assigner au plan, puis le nombre de fois que la texture sera r\'ep\'et\'ee dans les deux directions. 
\item le dernier param\`etre est le vecteur indiquant la direction du haut du mesh. Attention: il ne faut pas le confondre avec la normale du plan, qui est diff\'erente.
\end{itemize}

Il reste encore des param\`etres par d\'efaut que l'on verra plus tard.

Enfin, nous allons revenir vers un code connu: nous allons cr\'eer l'entit\'e qui repr\'esentera le plan. C'est le m\^eme principe que tout \`{a} l'heure:
\begin{itemize} 
\item tout d'abord, on cr\'ee une entit\'e \`{a} partir du sc\`ene Manager en la nommant et en lui indiquant le mesh \`{a} utiliser. 
\item On cr\'ee ensuite un nouveau noeud \`{a} partir du noeud racine et on l'attache \`{a} notre entit\'e.
\end{itemize}

\begin{lstlisting}
//creation d'une entite
Entity *ent= msceneMgr->createEntity(''EntiteSol'', ''sol'');

//creation d'un nouveau noeud
node = msceneMgr->getRootsceneNode()->createChildsceneNode();

//on attache le noeud a notre entite
node->attachObject(ent);
\end{lstlisting}




\subsection{Le mat\'eriau}

Nous allons finir en ajoutant une texture au sol: de l'herbe. Pour cela, il suffit de rajouter la ligne suivante apr\`es la cr\'eation de l'entit\'e:
\begin{lstlisting}
ent->setMaterialName(''Examples/GrassFloor'');
\end{lstlisting}

Si vous voulez conna\^itre les mat\'eriaux fournis avec Ogre, il vous suffit d'aller dans le dossier media/materials/scripts. Ici, on prend le mat\'eriau GrassFloor enregistr\'e dans le fichier Examples.material. 

Les textures correspondantes se trouvent dans le dossier media/materials/textures, si vous voulez faire des essais.


Vous pouvez maintenant ex\'ecuter votre programme.

Lancez l'application et remontez la cam\'era avec la souris et les touches de d\'eplacement, vous devriez voir quelque chose ressemblant \`{a} la capture suivante.

Image utilisateur

Euh... La t\^ete d'Ogre est coup\'ee par le sol en herbe...

En effet, notre plan est centr\'e sur l'origine de la sc\`ene, et l'on a aussi plac\'e notre t\^ete \`{a} l'origine. Mais quelle partie de la t\^ete est \`{a} l'altitude 0 ?

Ici, c'est donc un point au milieu de la t\^ete, puisque le plan d'herbe passe par l\`{a}.
Cependant, ce point n'est pas n\'ecessairement au milieu de l'objet que vous int\'egrez. Cela d\'epend de la personne qui a mod\'elis\'e l'objet et qui a donc d\'ecid\'e par rapport \`{a} quel point on allait d\'efinir la position du mesh. Pour un personnage, on pourrait mettre ce point \`{a} ses pieds, pour que l'altitude 0 corresponde effectivement au moment o\`{u} le personnage touche le sol avec ses pieds.

Pour corriger cela, il va falloir remonter notre noeud li\'e \`{a} notre entit\'e. C'est l'objet du prochain chapitre.

































\subsection{Code}

\subsubsection{PremiereApplication.cpp}
\begin{lstlisting}[caption={PremiereApplication.cpp: Cr\'eation d'un sol}]
#include "PremiereApplication.h"

void PremiereApplication::createScene()
{
    //creation d une entite
    Entity *head= mSceneMgr->createEntity("Tete", "ogrehead.mesh" );
    
    //creation d un noeud
    SceneNode *node= mSceneMgr->getRootSceneNode( )->createChildSceneNode( "nodeTete " , Vector3::ZERO, Quaternion::IDENTITY);
    
    node->yaw(Radian(Math::PI));
    node->yaw(Radian(Math::PI));

    //setPosition place le noeud aux coord passees en parametres
    Vector3 position = Vector3(30.0, 50.0, 0.0);
    node->setPosition(position);

    node->setPosition(30.0, 50.0, 0.0); 
    /*equivalent a
    Vector3 position = Vector3(30.0, 50.0, 0.0);
    node->setPosition(position);
    */

    //deplace le noeud par rapport a sa position actuelle
    node->translate(-30.0, 50.0, 0.0); //par defaut la trnslt se fait par rap a TS_WORLD
   
    //attachement de l entite au noeud
    node->attachObject ( head );

    //creation d un plan
    Plane plan(Vector3::UNIT_Y, 0);

    //creation d un mesh cad l objet 3d visible ds la scene
    MeshManager::getSingleton().createPlane("sol",
                ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME,
                plan, 500, 500, 1, 1, true, 1, 1, 1, Vector3::UNIT_Z); 

    //entite qui representera le plan
    Entity *ent= mSceneMgr->createEntity("EntiteSol", "sol");

    //ajout du materiau a l entite
    ent->setMaterialName("Examples/GrassFloor");//texture de pelouse
    /*les differents materiaux sont sous /media/materials/scritps, par ex:
    ent->setMaterialName("Examples/WaterStream");//texture d eau animee*/

    //creation d un noeud
    node = mSceneMgr->getRootSceneNode()->createChildSceneNode();
    node->attachObject(ent);
}


\end{lstlisting}

A cause de la position de la cam\'era, il se peut alors que le sol ne soit pas visible.

